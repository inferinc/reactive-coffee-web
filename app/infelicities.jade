extends layouts/development
block title
  | Infelicities - reactive.coffee
block content
  :markdown
    Infelicities
    ============

    There are a number of areas for immediate improvement, including but not
    limited to the following:

    ## Lazy Change Propagation

    This one is rather low-hanging fruit: when a cell's value has been set to the
    same value, we should not propagate events downstream to dependent nodes.

    ## Structural Attribute Bindings

    Currently, attributes are strings.  For most attributes this is fine, but for
    certain attributes such as `style`, we could have a simple convenience
    preprocessor that takes in an object map of the style names and renders the
    string.  This could be extended to lists for `class` and so on.

    ## More Combinators

    There are only a few combinators right now.  Besides `map`, we also are
    interested in adding (efficient implementations of) `filter`, `sort`,
    `fold`/`reduce`, etc.

    ## Topologically Ordered Visits

    If we consider the DAG of dependencies among observable nodes, when there's an
    event being propagated through the system, the notifications currently visit
    nodes in depth-first order.  However, the most efficient order in which to
    propagate changes is by processing the events of the nodes in topologically
    sorted order.  For instance, consider the following DAG:

        A -> B
        A -> C
        B -> D
        C -> D
        D -> E

    ![DAG](images/cell-dag.png)

    If `A` is updated, then we'd currently perform a recursive descent starting at
    `A` and visit the nodes in this order:

        A, B, D, E, C, D, E

    However, if we kept track of the DAG, then we could process the nodes in
    topologically sorted order:

        A, B, C, D, E

    This guarantees avoiding multiple visits to the same node.

    ## Garbage Collection

    Dependencies hold references to their dependents in order to know who to
    propagate updates to.  We do currently unsubscribe a dependent observable
    from its dependencies whenever that dependent is refreshed, but if the
    dependent observable itself creates nested binds, those nested binds may
    not be cleaned up.

    For instance, say we have:

    ```coffeescript
    showUnread = rx.cell(true)
    unread = rx.cell(0)
    div {class: 'scoreboard'}, bind -> [
      if showUnread.get()
        div {class: 'unread'}, bind -> "#{unread.get()} message(s)"
      else
        '(nothing shown)'
    ]
    ```

    Initially, `unread` has a subscriber, as expected: the inner `bind`.  When
    we update `showUnread`, the outer `bind` will re-evaluate and create a new
    inner `bind` (for the nested `div`), completely forgetting about the old
    one.  However, now `unread` has *two* subscribers, old and new inner
    `bind`s.  And since the old inner `bind` is still referenced from
    `unread`'s list of subscribers, it can't be garbage-collected.  Ergo,
    memory leak.

    What needs to happen: `bind` should track any nested `bind`s.  On
    re-evaluation, these inner `bind`s should be _disposed_ of, unsubscribing
    themselves from all their dependencies (thus dependency tracking is a
    pre-requisite).  This disposal should also occur recursively down to
    *their* nested `bind`s, and so on.  Languages with weak references have an
    easier time about this.

    ## Lazy Event Notification

    More flexible-but-still-efficient array (and other data structure) mutations.
    Currently arrays have built-in mechanisms for efficient propagation of events
    such as insertion, removal, splicing, etc.  However, for more involved
    transformations, or if we want to reuse existing array transformation code, we
    can still do better than re-evaluating all dependents downstream by figuring
    out what has changed, and then propagating the diff's or operations (such as
    reorderings) for more efficient downstream handling.

    This can be extended to arbitrary object types/data structures beyond arrays
    and should be configurable, with the ability to substitute in various change
    detection or diffing algorithms.

    ## Transitions

    Ability to apply animations and effects to things like entrances, exits, and
    reorderings.  See the [d3 transitions API] for something I'm keen on borrowing
    from.

    [d3 transitions API]: https://github.com/mbostock/d3/wiki/Transitions

    ## DAG Debugger

    A facility to visualize the DAG of dependencies would make code debugging
    and understanding easier.

    ## Tests

    And examples.  Need more tests and examples.  'Nuff said.
